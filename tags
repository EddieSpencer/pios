!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.6	//
ALT	dev/kbd.c	28;"	d	file:
ASM	lib/string.c	16;"	d	file:
ASM	obj/kern/kernel.asm	/^#define ASM 1$/;"	d
C	dev/kbd.c	94;"	d	file:
CAPSLOCK	dev/kbd.c	29;"	d	file:
CGA_BASE	dev/video.h	26;"	d
CGA_BUF	dev/video.h	27;"	d
CHECKSUM	kern/entry.S	/^#define CHECKSUM (-(MULTIBOOT_HEADER_MAGIC + MULTIBOOT_HEADER_FLAGS))$/;"	d
CMDBYTE	dev/kbd.h	77;"	d
COM1	dev/serial.h	23;"	d
COM_DLL	dev/serial.h	27;"	d
COM_DLM	dev/serial.h	28;"	d
COM_FCR	dev/serial.h	32;"	d
COM_IER	dev/serial.h	29;"	d
COM_IER_RDI	dev/serial.h	30;"	d
COM_IIR	dev/serial.h	31;"	d
COM_LCR	dev/serial.h	33;"	d
COM_LCR_DLAB	dev/serial.h	34;"	d
COM_LCR_WLEN8	dev/serial.h	35;"	d
COM_LSR	dev/serial.h	40;"	d
COM_LSR_DATA	dev/serial.h	41;"	d
COM_LSR_TSRE	dev/serial.h	43;"	d
COM_LSR_TXRDY	dev/serial.h	42;"	d
COM_MCR	dev/serial.h	36;"	d
COM_MCR_DTR	dev/serial.h	38;"	d
COM_MCR_OUT2	dev/serial.h	39;"	d
COM_MCR_RTS	dev/serial.h	37;"	d
COM_RX	dev/serial.h	25;"	d
COM_TX	dev/serial.h	26;"	d
CONSBUFSIZE	kern/cons.c	38;"	d	file:
CPUTS_MAX	inc/assert.h	20;"	d
CPUTS_MAX	lib/cprintf.c	28;"	d	file:
CPU_GDT_KCODE	kern/cpu.h	18;"	d
CPU_GDT_KDATA	kern/cpu.h	19;"	d
CPU_GDT_NDESC	kern/cpu.h	24;"	d
CPU_GDT_NULL	kern/cpu.h	17;"	d
CPU_GDT_TSS	kern/cpu.h	23;"	d
CPU_GDT_UCODE	kern/cpu.h	20;"	d
CPU_GDT_UDATA	kern/cpu.h	21;"	d
CPU_GDT_UDTLS	kern/cpu.h	22;"	d
CPU_MAGIC	kern/cpu.h	66;"	d
CR0_AM	inc/mmu.h	98;"	d
CR0_CD	inc/mmu.h	100;"	d
CR0_EM	inc/mmu.h	93;"	d
CR0_ET	inc/mmu.h	95;"	d
CR0_MP	inc/mmu.h	92;"	d
CR0_NE	inc/mmu.h	96;"	d
CR0_NW	inc/mmu.h	99;"	d
CR0_PE	inc/mmu.h	91;"	d
CR0_PG	inc/mmu.h	101;"	d
CR0_TS	inc/mmu.h	94;"	d
CR0_WP	inc/mmu.h	97;"	d
CR4_DE	inc/mmu.h	106;"	d
CR4_MCE	inc/mmu.h	109;"	d
CR4_OSFXSR	inc/mmu.h	112;"	d
CR4_OSXMMEXCPT	inc/mmu.h	113;"	d
CR4_PAE	inc/mmu.h	108;"	d
CR4_PCE	inc/mmu.h	111;"	d
CR4_PGE	inc/mmu.h	110;"	d
CR4_PSE	inc/mmu.h	107;"	d
CR4_PVI	inc/mmu.h	104;"	d
CR4_TSD	inc/mmu.h	105;"	d
CR4_VME	inc/mmu.h	103;"	d
CRT_COLS	dev/video.h	30;"	d
CRT_ROWS	dev/video.h	29;"	d
CRT_SIZE	dev/video.h	31;"	d
CTL	dev/kbd.c	27;"	d	file:
DEBUG_TRACEFRAMES	kern/cons.h	24;"	d
DEBUG_TRACEFRAMES	kern/debug.h	20;"	d
Disassembly	obj/boot/bootblock.asm	/^Disassembly of section .text:$/;"	l
Disassembly	obj/kern/kernel.asm	/^Disassembly of section .text:$/;"	l
E0ESC	dev/kbd.c	32;"	d	file:
ELFHDR	boot/main.c	41;"	d	file:
ELF_MAGIC	inc/elf.h	13;"	d
ELF_PROG_FLAG_EXEC	inc/elf.h	64;"	d
ELF_PROG_FLAG_READ	inc/elf.h	66;"	d
ELF_PROG_FLAG_WRITE	inc/elf.h	65;"	d
ELF_PROG_LOAD	inc/elf.h	61;"	d
ELF_SHN_UNDEF	inc/elf.h	75;"	d
ELF_SHT_NULL	inc/elf.h	69;"	d
ELF_SHT_PROGBITS	inc/elf.h	70;"	d
ELF_SHT_STRTAB	inc/elf.h	72;"	d
ELF_SHT_SYMTAB	inc/elf.h	71;"	d
EXIT_FAILURE	inc/stdlib.h	24;"	d
EXIT_SUCCESS	inc/stdlib.h	23;"	d
FL_AC	inc/x86.h	36;"	d
FL_AF	inc/x86.h	21;"	d
FL_CF	inc/x86.h	19;"	d
FL_DF	inc/x86.h	26;"	d
FL_ID	inc/x86.h	39;"	d
FL_IF	inc/x86.h	25;"	d
FL_IOPL_0	inc/x86.h	29;"	d
FL_IOPL_1	inc/x86.h	30;"	d
FL_IOPL_2	inc/x86.h	31;"	d
FL_IOPL_3	inc/x86.h	32;"	d
FL_IOPL_MASK	inc/x86.h	28;"	d
FL_NT	inc/x86.h	33;"	d
FL_OF	inc/x86.h	27;"	d
FL_PF	inc/x86.h	20;"	d
FL_RF	inc/x86.h	34;"	d
FL_SF	inc/x86.h	23;"	d
FL_TF	inc/x86.h	24;"	d
FL_VIF	inc/x86.h	37;"	d
FL_VIP	inc/x86.h	38;"	d
FL_VM	inc/x86.h	35;"	d
FL_ZF	inc/x86.h	22;"	d
F_ALT	lib/printfmt.c	38;"	d	file:
F_DOT	lib/printfmt.c	39;"	d	file:
F_L	lib/printfmt.c	36;"	d	file:
F_LL	lib/printfmt.c	37;"	d	file:
F_RPAD	lib/printfmt.c	40;"	d	file:
IO_RTC	dev/nvram.h	19;"	d
IRQ_IDE	inc/trap.h	59;"	d
IRQ_KBD	inc/trap.h	56;"	d
IRQ_SERIAL	inc/trap.h	57;"	d
IRQ_SPURIOUS	inc/trap.h	58;"	d
IRQ_TIMER	inc/trap.h	55;"	d
KBCMDP	dev/kbd.h	46;"	d
KBC_AUXDISABLE	dev/kbd.h	49;"	d
KBC_AUXECHO	dev/kbd.h	53;"	d
KBC_AUXENABLE	dev/kbd.h	50;"	d
KBC_AUXTEST	dev/kbd.h	51;"	d
KBC_AUXWRITE	dev/kbd.h	54;"	d
KBC_DISABLE	dev/kbd.h	83;"	d
KBC_ECHO	dev/kbd.h	88;"	d
KBC_ENABLE	dev/kbd.h	84;"	d
KBC_KBDDISABLE	dev/kbd.h	57;"	d
KBC_KBDECHO	dev/kbd.h	52;"	d
KBC_KBDENABLE	dev/kbd.h	58;"	d
KBC_KBDTEST	dev/kbd.h	56;"	d
KBC_MODEIND	dev/kbd.h	87;"	d
KBC_PULSE0	dev/kbd.h	59;"	d
KBC_PULSE1	dev/kbd.h	60;"	d
KBC_PULSE2	dev/kbd.h	61;"	d
KBC_PULSE3	dev/kbd.h	62;"	d
KBC_RAMREAD	dev/kbd.h	47;"	d
KBC_RAMWRITE	dev/kbd.h	48;"	d
KBC_RESEND	dev/kbd.h	81;"	d
KBC_RESET	dev/kbd.h	80;"	d
KBC_SELFTEST	dev/kbd.h	55;"	d
KBC_SETDEFAULT	dev/kbd.h	82;"	d
KBC_SETTABLE	dev/kbd.h	86;"	d
KBC_TYPEMATIC	dev/kbd.h	85;"	d
KBDATAP	dev/kbd.h	64;"	d
KBOUTP	dev/kbd.h	65;"	d
KBR_ACK	dev/kbd.h	93;"	d
KBR_BREAK	dev/kbd.h	96;"	d
KBR_ECHO	dev/kbd.h	98;"	d
KBR_EXTENDED	dev/kbd.h	91;"	d
KBR_FAILURE	dev/kbd.h	95;"	d
KBR_OVERRUN	dev/kbd.h	94;"	d
KBR_RESEND	dev/kbd.h	92;"	d
KBR_RSTDONE	dev/kbd.h	97;"	d
KBSTATP	dev/kbd.h	36;"	d
KBS_DIB	dev/kbd.h	37;"	d
KBS_IBF	dev/kbd.h	38;"	d
KBS_NOSEC	dev/kbd.h	41;"	d
KBS_OCMD	dev/kbd.h	40;"	d
KBS_PERR	dev/kbd.h	44;"	d
KBS_RERR	dev/kbd.h	43;"	d
KBS_TERR	dev/kbd.h	42;"	d
KBS_WARM	dev/kbd.h	39;"	d
KC8_CPU	dev/kbd.h	74;"	d
KC8_IGNSEC	dev/kbd.h	73;"	d
KC8_KDISABLE	dev/kbd.h	72;"	d
KC8_KENABLE	dev/kbd.h	76;"	d
KC8_MDISABLE	dev/kbd.h	71;"	d
KC8_MENABLE	dev/kbd.h	75;"	d
KC8_TRANS	dev/kbd.h	70;"	d
KEY_DEL	dev/kbd.h	31;"	d
KEY_DN	dev/kbd.h	25;"	d
KEY_END	dev/kbd.h	23;"	d
KEY_HOME	dev/kbd.h	22;"	d
KEY_INS	dev/kbd.h	30;"	d
KEY_LF	dev/kbd.h	26;"	d
KEY_PGDN	dev/kbd.h	29;"	d
KEY_PGUP	dev/kbd.h	28;"	d
KEY_RT	dev/kbd.h	27;"	d
KEY_UP	dev/kbd.h	24;"	d
K_LDCMDBYTE	dev/kbd.h	68;"	d
K_RDCMDBYTE	dev/kbd.h	67;"	d
LAB	conf/lab.mk	/^LAB=1$/;"	m
MAX	inc/types.h	72;"	d
MC_NVRAM_SIZE	dev/nvram.h	22;"	d
MC_NVRAM_START	dev/nvram.h	21;"	d
MEM_EXT	kern/mem.h	26;"	d
MEM_IO	kern/mem.h	25;"	d
MIN	inc/types.h	66;"	d
MONO_BASE	dev/video.h	24;"	d
MONO_BUF	dev/video.h	25;"	d
MULTIBOOT_HEADER_FLAGS	kern/entry.S	/^#define MULTIBOOT_HEADER_FLAGS (MULTIBOOT_MEMORY_INFO | MULTIBOOT_PAGE_ALIGN)$/;"	d
MULTIBOOT_HEADER_MAGIC	kern/entry.S	/^#define MULTIBOOT_HEADER_MAGIC (0x1BADB002)$/;"	d
MULTIBOOT_MEMORY_INFO	kern/entry.S	/^#define MULTIBOOT_MEMORY_INFO (1<<1)$/;"	d
MULTIBOOT_PAGE_ALIGN	kern/entry.S	/^#define MULTIBOOT_PAGE_ALIGN  (1<<0)$/;"	d
NO	dev/kbd.c	24;"	d	file:
NPDENTRIES	inc/mmu.h	59;"	d
NPTENTRIES	inc/mmu.h	60;"	d
NULL	inc/stdio.h	20;"	d
NULL	inc/stdlib.h	18;"	d
NULL	inc/types.h	21;"	d
NUMLOCK	dev/kbd.c	30;"	d	file:
NVRAM_BASEHI	dev/nvram.h	26;"	d
NVRAM_BASELO	dev/nvram.h	25;"	d
NVRAM_CENTURY	dev/nvram.h	37;"	d
NVRAM_EXTHI	dev/nvram.h	30;"	d
NVRAM_EXTLO	dev/nvram.h	29;"	d
NVRAM_PEXTHI	dev/nvram.h	34;"	d
NVRAM_PEXTLO	dev/nvram.h	33;"	d
PACKAGEDATE	conf/lab.mk	/^PACKAGEDATE=Sat Jan 15 18:24:38 EST 2011$/;"	m
PAGESHIFT	inc/mmu.h	63;"	d
PAGESIZE	inc/mmu.h	62;"	d
PDX	inc/mmu.h	45;"	d
PDXSHIFT	inc/mmu.h	69;"	d
PFE_PR	inc/mmu.h	116;"	d
PFE_U	inc/mmu.h	118;"	d
PFE_WR	inc/mmu.h	117;"	d
PGADDR	inc/mmu.h	52;"	d
PGOFF	inc/mmu.h	53;"	d
PIOS_DEV_NVRAM_H	dev/nvram.h	14;"	d
PIOS_INC_ASSERT_H	inc/assert.h	12;"	d
PIOS_INC_CDEFS_H	inc/cdefs.h	4;"	d
PIOS_INC_ELF_H	inc/elf.h	11;"	d
PIOS_INC_MMU_H	inc/mmu.h	11;"	d
PIOS_INC_STDARG_H	inc/stdarg.h	11;"	d
PIOS_INC_STDIO_H	inc/stdio.h	14;"	d
PIOS_INC_STDLIB_H	inc/stdlib.h	12;"	d
PIOS_INC_STRING_H	inc/string.h	12;"	d
PIOS_INC_TRAP_H	inc/trap.h	12;"	d
PIOS_INC_TYPES_H	inc/types.h	18;"	d
PIOS_INC_X86_H	inc/x86.h	12;"	d
PIOS_KERN_CONSOLE_H_	kern/cons.h	16;"	d
PIOS_KERN_DEBUG_H_	kern/debug.h	11;"	d
PIOS_KERN_INIT_H	kern/init.h	12;"	d
PIOS_KERN_KBD_H_	dev/kbd.h	15;"	d
PIOS_KERN_MEM_H	kern/mem.h	12;"	d
PIOS_KERN_SEG_H	kern/cpu.h	10;"	d
PIOS_KERN_SERIAL_H_	dev/serial.h	15;"	d
PIOS_KERN_TRAP_H	kern/trap.h	12;"	d
PIOS_KERN_VIDEO_H_	dev/video.h	15;"	d
PPN	inc/mmu.h	41;"	d
PTADDR	inc/mmu.h	55;"	d
PTE_A	inc/mmu.h	77;"	d
PTE_AVAIL	inc/mmu.h	85;"	d
PTE_D	inc/mmu.h	78;"	d
PTE_G	inc/mmu.h	81;"	d
PTE_P	inc/mmu.h	72;"	d
PTE_PAT	inc/mmu.h	80;"	d
PTE_PCD	inc/mmu.h	76;"	d
PTE_PS	inc/mmu.h	79;"	d
PTE_PWT	inc/mmu.h	75;"	d
PTE_U	inc/mmu.h	74;"	d
PTE_USER	inc/mmu.h	88;"	d
PTE_W	inc/mmu.h	73;"	d
PTOFF	inc/mmu.h	56;"	d
PTSHIFT	inc/mmu.h	66;"	d
PTSIZE	inc/mmu.h	65;"	d
PTX	inc/mmu.h	49;"	d
PTXSHIFT	inc/mmu.h	68;"	d
ROOTEXE_START	kern/init.c	28;"	d	file:
ROUNDDOWN	inc/types.h	81;"	d
ROUNDUP	inc/types.h	87;"	d
SCROLLLOCK	dev/kbd.c	31;"	d	file:
SECTSIZE	boot/main.c	40;"	d	file:
SEG	inc/mmu.h	135;"	d
SEGDESC16	inc/mmu.h	170;"	d
SEGDESC32	inc/mmu.h	166;"	d
SEGDESC_FAULT	inc/mmu.h	164;"	d
SEGDESC_NULL	inc/mmu.h	162;"	d
SEG_NULL	inc/mmu.h	132;"	d
SETCALLGATE	inc/mmu.h	283;"	d
SETGATE	inc/mmu.h	269;"	d
SHIFT	dev/kbd.c	26;"	d	file:
SIZEOF_STRUCT_TRAPFRAME	inc/trap.h	143;"	d
STA_A	inc/mmu.h	183;"	d
STA_C	inc/mmu.h	180;"	d
STA_E	inc/mmu.h	179;"	d
STA_R	inc/mmu.h	182;"	d
STA_W	inc/mmu.h	181;"	d
STA_X	inc/mmu.h	178;"	d
STS_CG16	inc/mmu.h	189;"	d
STS_CG32	inc/mmu.h	195;"	d
STS_IG16	inc/mmu.h	191;"	d
STS_IG32	inc/mmu.h	196;"	d
STS_LDT	inc/mmu.h	187;"	d
STS_T16A	inc/mmu.h	186;"	d
STS_T16B	inc/mmu.h	188;"	d
STS_T32A	inc/mmu.h	193;"	d
STS_T32B	inc/mmu.h	194;"	d
STS_TG	inc/mmu.h	190;"	d
STS_TG16	inc/mmu.h	192;"	d
STS_TG32	inc/mmu.h	197;"	d
TRAPHANDLER	kern/trapasm.S	/^#define TRAPHANDLER(name, num)						\\$/;"	d
TRAPHANDLER_NOEC	kern/trapasm.S	/^#define TRAPHANDLER_NOEC(name, num)					\\$/;"	d
T_ALIGN	inc/trap.h	36;"	d
T_BOUND	inc/trap.h	24;"	d
T_BRKPT	inc/trap.h	22;"	d
T_DBLFLT	inc/trap.h	27;"	d
T_DEBUG	inc/trap.h	20;"	d
T_DEFAULT	inc/trap.h	51;"	d
T_DEVICE	inc/trap.h	26;"	d
T_DIVIDE	inc/trap.h	19;"	d
T_FPERR	inc/trap.h	35;"	d
T_GPFLT	inc/trap.h	32;"	d
T_ICNT	inc/trap.h	52;"	d
T_ILLOP	inc/trap.h	25;"	d
T_IRQ0	inc/trap.h	41;"	d
T_LERROR	inc/trap.h	49;"	d
T_LTIMER	inc/trap.h	48;"	d
T_MCHK	inc/trap.h	37;"	d
T_NMI	inc/trap.h	21;"	d
T_OFLOW	inc/trap.h	23;"	d
T_PGFLT	inc/trap.h	33;"	d
T_SECEV	inc/trap.h	39;"	d
T_SEGNP	inc/trap.h	30;"	d
T_SIMD	inc/trap.h	38;"	d
T_STACK	inc/trap.h	31;"	d
T_SYSCALL	inc/trap.h	45;"	d
T_TSS	inc/trap.h	29;"	d
USED	inc/types.h	97;"	d
V	conf/env.mk	/^V = @$/;"	m
VPD	inc/mmu.h	46;"	d
VPN	inc/mmu.h	42;"	d
__va_size	inc/stdarg.h	15;"	d
addr_6845	dev/video.c	/^static unsigned addr_6845;$/;"	v	file:
addr_6845	obj/kern/kernel.asm	/^		addr_6845 = CGA_BASE;$/;"	d
addr_6845	obj/kern/kernel.asm	/^		addr_6845 = MONO_BASE;$/;"	d
assert	inc/assert.h	31;"	d
assert	inc/assert.h	34;"	d
available	inc/trap.h	/^	uint8_t		available[3][16];	\/\/ byte 464: available to OS$/;"	m	struct:fxsave
base	lib/printfmt.c	/^	int base;		\/\/ base for numeric output$/;"	m	struct:printstate	file:
bool	inc/types.h	/^typedef int bool;$/;"	t
bootmain	boot/main.c	/^bootmain(void)$/;"	f
breakpoint	inc/x86.h	/^breakpoint(void)$/;"	f
buf	kern/cons.c	/^	uint8_t buf[CONSBUFSIZE];$/;"	m	struct:__anon1	file:
buf	lib/cprintf.c	/^	char buf[CPUTS_MAX];$/;"	m	struct:printbuf	file:
c	obj/kern/kernel.asm	/^		c = (c<<24)|(c<<16)|(c<<8)|c;$/;"	d
c	obj/kern/kernel.asm	/^		c = cons.buf[cons.rpos++];$/;"	d
c	obj/kern/kernel.asm	/^	c = charcode[shift & (CTL | SHIFT)][data];$/;"	d
ch	obj/kern/kernel.asm	/^				ch = *fmt;$/;"	d
char	obj/kern/kernel.asm	/^char *$/;"	l
charcode	dev/kbd.c	/^static uint8_t *charcode[4] = {$/;"	v	file:
cli	inc/x86.h	/^cli(void)$/;"	f
cnt	lib/cprintf.c	/^	int cnt;	\/\/ total bytes printed so far$/;"	m	struct:printbuf	file:
cnt	obj/kern/kernel.asm	/^	cnt = vcprintf(fmt, ap);$/;"	d
cons	kern/cons.c	/^} cons;$/;"	v	typeref:struct:__anon1	file:
cons_getc	kern/cons.c	/^cons_getc(void)$/;"	f
cons_init	kern/cons.c	/^cons_init(void)$/;"	f
cons_intr	kern/cons.c	/^cons_intr(int (*proc)(void))$/;"	f
cons_putc	kern/cons.c	/^cons_putc(int c)$/;"	f	file:
const	obj/kern/kernel.asm	/^const char *trap_name(int trapno)$/;"	l
cp	obj/kern/kernel.asm	/^		cp = (uint16_t*) mem_ptr(MONO_BUF);$/;"	d
cp	obj/kern/kernel.asm	/^	cp = (uint16_t*) mem_ptr(CGA_BUF);$/;"	d
cprintf	lib/cprintf.c	/^cprintf(const char *fmt, ...)$/;"	f
cpu	kern/cpu.h	/^typedef struct cpu {$/;"	s
cpu	kern/cpu.h	/^} cpu;$/;"	t	typeref:struct:cpu
cpu_boot	kern/cpu.c	/^cpu cpu_boot = {$/;"	v
cpu_cur	kern/cpu.h	/^cpu_cur() {$/;"	f
cpu_disabled	kern/cpu.h	73;"	d
cpu_init	kern/cpu.c	/^void cpu_init()$/;"	f
cpu_onboot	kern/cpu.h	/^cpu_onboot() {$/;"	f
cpuid	inc/x86.h	/^cpuid(uint32_t idx, cpuinfo *info)$/;"	f
cpuinfo	inc/x86.h	/^typedef struct cpuinfo {$/;"	s
cpuinfo	inc/x86.h	/^} cpuinfo;$/;"	t	typeref:struct:cpuinfo
cputs	kern/cons.c	/^cputs(const char *str)$/;"	f
crt_buf	dev/video.c	/^static uint16_t *crt_buf;$/;"	v	file:
crt_buf	obj/kern/kernel.asm	/^	crt_buf = (uint16_t*) cp;$/;"	d
crt_pos	dev/video.c	/^static uint16_t crt_pos;$/;"	v	file:
crt_pos	obj/kern/kernel.asm	/^	crt_pos = pos;$/;"	d
cs	inc/trap.h	/^	uint16_t	cs;$/;"	m	struct:fxsave
cs	inc/trap.h	/^	uint16_t cs; 		uint16_t padding_cs;$/;"	m	struct:trapframe
ctlmap	dev/kbd.c	/^static uint8_t ctlmap[256] = $/;"	v	file:
d	obj/kern/kernel.asm	/^	d = dst;$/;"	d
data	obj/kern/kernel.asm	/^		data = (shift & E0ESC ? data : data & 0x7F);$/;"	d
data	obj/kern/kernel.asm	/^	data = inb(KBDATAP);$/;"	d
dead	obj/kern/kernel.asm	/^dead:$/;"	l
debug_check	kern/debug.c	/^debug_check(void)$/;"	f
debug_panic	kern/debug.c	/^debug_panic(const char *file, int line, const char *fmt,...)$/;"	f
debug_trace	kern/debug.c	/^debug_trace(uint32_t ebp, uint32_t eips[DEBUG_TRACEFRAMES])$/;"	f
debug_warn	kern/debug.c	/^debug_warn(const char *file, int line, const char *fmt,...)$/;"	f
default	obj/kern/kernel.asm	/^		default:$/;"	l
default	obj/kern/kernel.asm	/^	default:$/;"	l
delay	dev/serial.c	/^delay(void)$/;"	f	file:
done	kern/init.c	/^done()$/;"	f
double_t	inc/types.h	/^typedef	double			double_t;$/;"	t
ds	inc/trap.h	/^	uint16_t	ds;$/;"	m	struct:fxsave
ds	inc/trap.h	/^	uint16_t ds; 		uint16_t padding_ds;$/;"	m	struct:trapframe
dst_in	obj/kern/kernel.asm	/^	dst_in = dst;$/;"	d
dump	inc/assert.h	28;"	d
e_ehsize	inc/elf.h	/^	uint16_t e_ehsize;$/;"	m	struct:elfhdf
e_elf	inc/elf.h	/^	uint8_t e_elf[12];$/;"	m	struct:elfhdf
e_entry	inc/elf.h	/^	uint32_t e_entry;$/;"	m	struct:elfhdf
e_flags	inc/elf.h	/^	uint32_t e_flags;$/;"	m	struct:elfhdf
e_machine	inc/elf.h	/^	uint16_t e_machine;$/;"	m	struct:elfhdf
e_magic	inc/elf.h	/^	uint32_t e_magic;	\/\/ must equal ELF_MAGIC$/;"	m	struct:elfhdf
e_phentsize	inc/elf.h	/^	uint16_t e_phentsize;$/;"	m	struct:elfhdf
e_phnum	inc/elf.h	/^	uint16_t e_phnum;$/;"	m	struct:elfhdf
e_phoff	inc/elf.h	/^	uint32_t e_phoff;$/;"	m	struct:elfhdf
e_shentsize	inc/elf.h	/^	uint16_t e_shentsize;$/;"	m	struct:elfhdf
e_shnum	inc/elf.h	/^	uint16_t e_shnum;$/;"	m	struct:elfhdf
e_shoff	inc/elf.h	/^	uint32_t e_shoff;$/;"	m	struct:elfhdf
e_shstrndx	inc/elf.h	/^	uint16_t e_shstrndx;$/;"	m	struct:elfhdf
e_type	inc/elf.h	/^	uint16_t e_type;$/;"	m	struct:elfhdf
e_version	inc/elf.h	/^	uint32_t e_version;$/;"	m	struct:elfhdf
eax	inc/trap.h	/^	uint32_t eax;$/;"	m	struct:pushregs
eax	inc/x86.h	/^	uint32_t	eax;$/;"	m	struct:cpuinfo
ebp	inc/trap.h	/^	uint32_t ebp;$/;"	m	struct:pushregs
ebx	inc/trap.h	/^	uint32_t ebx;$/;"	m	struct:pushregs
ebx	inc/x86.h	/^	uint32_t	ebx;$/;"	m	struct:cpuinfo
echo_n	misc/grade-functions.sh	/^echo_n () {$/;"	f
ecx	inc/trap.h	/^	uint32_t ecx;$/;"	m	struct:pushregs
ecx	inc/x86.h	/^	uint32_t	ecx;$/;"	m	struct:cpuinfo
edi	inc/trap.h	/^	uint32_t edi;$/;"	m	struct:pushregs
edx	inc/trap.h	/^	uint32_t edx;$/;"	m	struct:pushregs
edx	inc/x86.h	/^	uint32_t	edx;$/;"	m	struct:cpuinfo
eflags	inc/trap.h	/^	uint32_t eflags;$/;"	m	struct:trapframe
eip	inc/trap.h	/^	uintptr_t eip;$/;"	m	struct:trapframe
elfhdf	inc/elf.h	/^typedef struct elfhdf {$/;"	s
elfhdr	inc/elf.h	/^} elfhdr;$/;"	t	typeref:struct:elfhdf
err	inc/trap.h	/^	uint32_t err;$/;"	m	struct:trapframe
es	inc/trap.h	/^	uint16_t es;		uint16_t padding_es;$/;"	m	struct:trapframe
esi	inc/trap.h	/^	uint32_t esi;$/;"	m	struct:pushregs
esp	inc/trap.h	/^	uintptr_t esp;$/;"	m	struct:trapframe
extmem	obj/kern/kernel.asm	/^	extmem = 1024*1024*1024 - MEM_EXT;	\/\/ assume 1GB total memory$/;"	d
f1	kern/debug.c	/^static void gcc_noinline f1(int r, uint32_t *e) { r & 1 ? f2(r,e) : f2(r,e); }$/;"	f	file:
f2	kern/debug.c	/^static void gcc_noinline f2(int r, uint32_t *e) { r & 2 ? f3(r,e) : f3(r,e); }$/;"	f	file:
f3	kern/debug.c	/^static void gcc_noinline f3(int r, uint32_t *e) { debug_trace(read_ebp(), e); }$/;"	f	file:
fail	misc/grade-functions.sh	/^fail () {$/;"	f
false	inc/types.h	26;"	d
fcw	inc/trap.h	/^	uint16_t	fcw;			\/\/ byte 0$/;"	m	struct:fxsave
fl	obj/kern/kernel.asm	/^	fl = mem_freelist;$/;"	d
flags	lib/printfmt.c	/^	int flags;		\/\/ flags below$/;"	m	struct:printstate	file:
float_t	inc/types.h	/^typedef	float			float_t;$/;"	t
fop	inc/trap.h	/^	uint16_t	fop;$/;"	m	struct:fxsave
fpu_dp	inc/trap.h	/^	uint32_t	fpu_dp;			\/\/ byte 16$/;"	m	struct:fxsave
fpu_ip	inc/trap.h	/^	uint32_t	fpu_ip;$/;"	m	struct:fxsave
frame	obj/kern/kernel.asm	/^    frame = (uint32_t*)frame[0];  \/\/ prev ebp saved at ebp 0$/;"	d
free_next	kern/mem.h	/^	struct pageinfo	*free_next;	\/\/ Next page number on free list$/;"	m	struct:pageinfo	typeref:struct:pageinfo::pageinfo
freetail	obj/kern/kernel.asm	/^		freetail = &mem_pageinfo[i].free_next;$/;"	d
fs	inc/trap.h	/^	uint16_t fs; 		uint16_t padding_fs;$/;"	m	struct:trapframe
fsw	inc/trap.h	/^	uint16_t	fsw;$/;"	m	struct:fxsave
ftw	inc/trap.h	/^	uint16_t	ftw;$/;"	m	struct:fxsave
fxsave	inc/trap.h	/^typedef gcc_aligned(16) struct fxsave {$/;"	s
fxsave	inc/trap.h	/^} fxsave;$/;"	v	typeref:struct:fxsave
gatedesc	inc/mmu.h	/^typedef struct gatedesc {$/;"	s
gatedesc	inc/mmu.h	/^} gatedesc;$/;"	t	typeref:struct:gatedesc
gcc_aligned	inc/cdefs.h	8;"	d
gcc_inline	inc/cdefs.h	16;"	d
gcc_noinline	inc/cdefs.h	19;"	d
gcc_noreturn	inc/cdefs.h	23;"	d
gcc_packed	inc/cdefs.h	11;"	d
gcc_pure	inc/cdefs.h	27;"	d
gcc_pure2	inc/cdefs.h	28;"	d
gd_args	inc/mmu.h	/^	unsigned gd_args : 5;        \/\/ # args, 0 for interrupt\/trap gates$/;"	m	struct:gatedesc
gd_dpl	inc/mmu.h	/^	unsigned gd_dpl : 2;         \/\/ descriptor(meaning new) privilege level$/;"	m	struct:gatedesc
gd_off_15_0	inc/mmu.h	/^	unsigned gd_off_15_0 : 16;   \/\/ low 16 bits of offset in segment$/;"	m	struct:gatedesc
gd_off_31_16	inc/mmu.h	/^	unsigned gd_off_31_16 : 16;  \/\/ high bits of offset in segment$/;"	m	struct:gatedesc
gd_p	inc/mmu.h	/^	unsigned gd_p : 1;           \/\/ Present$/;"	m	struct:gatedesc
gd_rsv1	inc/mmu.h	/^	unsigned gd_rsv1 : 3;        \/\/ reserved(should be zero I guess)$/;"	m	struct:gatedesc
gd_s	inc/mmu.h	/^	unsigned gd_s : 1;           \/\/ must be 0 (system)$/;"	m	struct:gatedesc
gd_ss	inc/mmu.h	/^	unsigned gd_ss : 16;         \/\/ segment selector$/;"	m	struct:gatedesc
gd_type	inc/mmu.h	/^	unsigned gd_type : 4;        \/\/ type(STS_{TG,IG32,TG32})$/;"	m	struct:gatedesc
gdt	boot/boot.S	/^gdt:$/;"	l
gdt	kern/cpu.h	/^	segdesc		gdt[CPU_GDT_NDESC];$/;"	m	struct:cpu
gdtdesc	boot/boot.S	/^gdtdesc:$/;"	l
genfint	lib/printfmt.c	/^genfint(printstate *st, char *p, double num)$/;"	f	file:
genfrac	lib/printfmt.c	/^genfrac(printstate *st, char *p, double num, int fmtch)$/;"	f	file:
genint	lib/printfmt.c	/^genint(printstate *st, char *p, uintmax_t num)$/;"	f	file:
getint	lib/printfmt.c	/^getint(printstate *st, va_list *ap)$/;"	f	file:
getuint	lib/printfmt.c	/^getuint(printstate *st, va_list *ap)$/;"	f	file:
gotprec	obj/kern/kernel.asm	/^		gotprec:$/;"	l
greptest	misc/grade-functions.sh	/^greptest () {$/;"	f
grmltest	misc/grade-functions.sh	/^grmltest () {$/;"	f
gs	inc/trap.h	/^	uint16_t gs;		uint16_t padding_gs;$/;"	m	struct:trapframe
idt	kern/trap.c	/^static struct gatedesc idt[256];$/;"	v	typeref:struct:gatedesc	file:
idt_pd	kern/trap.c	/^static struct pseudodesc idt_pd = {$/;"	v	typeref:struct:pseudodesc	file:
idx	lib/cprintf.c	/^	int idx;	\/\/ current buffer index$/;"	m	struct:printbuf	file:
inb	inc/x86.h	/^inb(int port)$/;"	f
init	kern/init.c	/^init(void)$/;"	f
inl	inc/x86.h	/^inl(int port)$/;"	f
ino_t	inc/types.h	/^typedef int			ino_t;		\/\/ file inode numbers$/;"	t
insb	inc/x86.h	/^insb(int port, void *addr, int cnt)$/;"	f
insl	inc/x86.h	/^insl(int port, void *addr, int cnt)$/;"	f
insw	inc/x86.h	/^insw(int port, void *addr, int cnt)$/;"	f
int	obj/kern/kernel.asm	/^int$/;"	l
int16_t	inc/types.h	/^typedef short			int16_t;$/;"	t
int32_t	inc/types.h	/^typedef int			int32_t;$/;"	t
int64_t	inc/types.h	/^typedef long long		int64_t;$/;"	t
int8_t	inc/types.h	/^typedef signed char		int8_t;$/;"	t
intmax_t	inc/types.h	/^typedef long long		intmax_t;$/;"	t
intptr_t	inc/types.h	/^typedef int			intptr_t;	\/\/ pointer-size signed integer$/;"	t
invlpg	inc/x86.h	/^invlpg(void *addr)$/;"	f
inw	inc/x86.h	/^inw(int port)$/;"	f
kbd_init	dev/kbd.c	/^kbd_init(void)$/;"	f
kbd_intr	dev/kbd.c	/^kbd_intr(void)$/;"	f
kbd_proc_data	dev/kbd.c	/^kbd_proc_data(void)$/;"	f	file:
kstackhi	kern/cpu.h	/^	char gcc_aligned(PAGESIZE) kstackhi[0];$/;"	m	struct:cpu
kstacklo	kern/cpu.h	/^	char		kstacklo[1];$/;"	m	struct:cpu
l10	obj/kern/kernel.asm	/^		l10 = -l10, st->signc = '-';$/;"	d
lcr0	inc/x86.h	/^lcr0(uint32_t val)$/;"	f
lcr3	inc/x86.h	/^lcr3(uint32_t val)$/;"	f
lcr4	inc/x86.h	/^lcr4(uint32_t val)$/;"	f
lidt	inc/x86.h	/^lidt(void *p)$/;"	f
lim	obj/kern/kernel.asm	/^		lim = str + maxlen;$/;"	d
lim	obj/kern/kernel.asm	/^		lim = strchr(str, 0);	\/\/ find the terminating null$/;"	d
lldt	inc/x86.h	/^lldt(uint16_t sel)$/;"	f
lockadd	inc/x86.h	/^lockadd(volatile int32_t *addr, int32_t incr)$/;"	f
lockaddz	inc/x86.h	/^lockaddz(volatile int32_t *addr, int32_t incr)$/;"	f
ltr	inc/x86.h	/^ltr(uint16_t sel)$/;"	f
m	obj/kern/kernel.asm	/^	m = n;$/;"	d
magic	kern/cpu.h	/^	uint32_t	magic;$/;"	m	struct:cpu
mem_alloc	kern/mem.c	/^mem_alloc(void)$/;"	f
mem_check	kern/mem.c	/^mem_check()$/;"	f
mem_decref	kern/mem.h	/^mem_decref(pageinfo* pi, void (*freefun)(pageinfo *pi))$/;"	f
mem_free	kern/mem.c	/^mem_free(pageinfo *pi)$/;"	f
mem_freelist	kern/mem.c	/^pageinfo *mem_freelist;		\/\/ Start of free page list$/;"	v
mem_freelist	obj/kern/kernel.asm	/^	mem_freelist = 0;$/;"	d
mem_freelist	obj/kern/kernel.asm	/^	mem_freelist = fl;$/;"	d
mem_incref	kern/mem.h	/^mem_incref(pageinfo *pi)$/;"	f
mem_init	kern/mem.c	/^mem_init(void)$/;"	f
mem_max	kern/mem.c	/^size_t mem_max;			\/\/ Maximum physical address$/;"	v
mem_max	obj/kern/kernel.asm	/^	mem_max = MEM_EXT + extmem;$/;"	d
mem_npage	kern/mem.c	/^size_t mem_npage;		\/\/ Total number of physical memory pages$/;"	v
mem_npage	obj/kern/kernel.asm	/^	mem_npage = mem_max \/ PAGESIZE;$/;"	d
mem_pageinfo	kern/mem.c	/^pageinfo *mem_pageinfo;		\/\/ Metadata array indexed by page number$/;"	v
mem_phys	kern/mem.h	38;"	d
mem_phys2pi	kern/mem.h	58;"	d
mem_pi2phys	kern/mem.h	59;"	d
mem_pi2ptr	kern/mem.h	61;"	d
mem_ptr	kern/mem.h	35;"	d
mem_ptr2pi	kern/mem.h	60;"	d
memchr	lib/string.c	/^memchr(const void *s, int c, size_t n)$/;"	f
memcmp	lib/string.c	/^memcmp(const void *v1, const void *v2, size_t n)$/;"	f
memcpy	lib/string.c	/^memcpy(void *dst, const void *src, size_t n)$/;"	f
memmove	lib/string.c	/^memmove(void *dst, const void *src, size_t n)$/;"	f
memset	lib/string.c	/^memset(void *v, int c, size_t n)$/;"	f
mode_t	inc/types.h	/^typedef int			mode_t;		\/\/ file mode flags$/;"	t
mxcsr	inc/trap.h	/^	uint32_t	mxcsr;$/;"	m	struct:fxsave
mxcsr_mask	inc/trap.h	/^	uint32_t	mxcsr_mask;$/;"	m	struct:fxsave
name	kern/trapasm.S	/^	name:								\\$/;"	l
name	kern/trapasm.S	/^	name:			\/* function starts here *\/		\\$/;"	l
normalmap	dev/kbd.c	/^static uint8_t normalmap[256] =$/;"	v	file:
num	obj/kern/kernel.asm	/^				num = -(intmax_t) num;$/;"	d
num	obj/kern/kernel.asm	/^			num = getint(&st, &ap);$/;"	d
nvram_read	dev/nvram.c	/^nvram_read(unsigned reg)$/;"	f
nvram_read16	dev/nvram.c	/^nvram_read16(unsigned r)$/;"	f
nvram_write	dev/nvram.c	/^nvram_write(unsigned reg, unsigned datum)$/;"	f
oesp	inc/trap.h	/^	uint32_t oesp;		\/* Useless *\/$/;"	m	struct:pushregs
off_t	inc/types.h	/^typedef int			off_t;		\/\/ file offsets and lengths$/;"	t
offsetof	inc/types.h	94;"	d
outb	inc/x86.h	/^outb(int port, uint8_t data)$/;"	f
outl	inc/x86.h	/^outl(int port, uint32_t data)$/;"	f
outsb	inc/x86.h	/^outsb(int port, const void *addr, int cnt)$/;"	f
outsl	inc/x86.h	/^outsl(int port, const void *addr, int cnt)$/;"	f
outsw	inc/x86.h	/^outsw(int port, const void *addr, int cnt)$/;"	f
outw	inc/x86.h	/^outw(int port, uint16_t data)$/;"	f
p	obj/kern/kernel.asm	/^		p = genfint(st, p, num \/ 10.0);	\/\/ recursively print higher digits$/;"	d
p	obj/kern/kernel.asm	/^		p = genint(st, p, num \/ st->base);	\/\/ output higher digits$/;"	d
p	obj/kern/kernel.asm	/^	p = genfint(st, p, num);			\/\/ sign and integer part$/;"	d
p	obj/kern/kernel.asm	/^	p = genfint(st, p, num);		\/\/ generate sign and integer part$/;"	d
p	obj/kern/kernel.asm	/^	p = genfrac(st, p, num, fmtch);			\/\/ '.' and fractional part$/;"	d
p	obj/kern/kernel.asm	/^	p = genfrac(st, p, num, fmtch);		\/\/ generate '.' and fractional part$/;"	d
p	obj/kern/kernel.asm	/^	p = genint(st, p, l10 \/ 10);		\/\/ at least 2 digits$/;"	d
p	obj/kern/kernel.asm	/^	p = genint(st, p, num);		\/\/ output to the string buffer$/;"	d
p	obj/kern/kernel.asm	/^	p = v;$/;"	d
p_align	inc/elf.h	/^	uint32_t p_align;$/;"	m	struct:proghdr
p_filesz	inc/elf.h	/^	uint32_t p_filesz;$/;"	m	struct:proghdr
p_flags	inc/elf.h	/^	uint32_t p_flags;$/;"	m	struct:proghdr
p_memsz	inc/elf.h	/^	uint32_t p_memsz;$/;"	m	struct:proghdr
p_offset	inc/elf.h	/^	uint32_t p_offset;$/;"	m	struct:proghdr
p_pa	inc/elf.h	/^	uint32_t p_pa;$/;"	m	struct:proghdr
p_type	inc/elf.h	/^	uint32_t p_type;$/;"	m	struct:proghdr
p_va	inc/elf.h	/^	uint32_t p_va;$/;"	m	struct:proghdr
padc	lib/printfmt.c	/^	int padc;		\/\/ left pad character, ' ' or '0'$/;"	m	struct:printstate	file:
padding_cs	inc/trap.h	/^	uint16_t cs; 		uint16_t padding_cs;$/;"	m	struct:trapframe
padding_ds	inc/trap.h	/^	uint16_t ds; 		uint16_t padding_ds;$/;"	m	struct:trapframe
padding_es	inc/trap.h	/^	uint16_t es;		uint16_t padding_es;$/;"	m	struct:trapframe
padding_fs	inc/trap.h	/^	uint16_t fs; 		uint16_t padding_fs;$/;"	m	struct:trapframe
padding_gs	inc/trap.h	/^	uint16_t gs;		uint16_t padding_gs;$/;"	m	struct:trapframe
padding_ss	inc/trap.h	/^	uint16_t ss;		uint16_t padding_ss;$/;"	m	struct:trapframe
pageinfo	kern/mem.h	/^typedef struct pageinfo {$/;"	s
pageinfo	kern/mem.h	/^} pageinfo;$/;"	t	typeref:struct:pageinfo
pageinfo	obj/kern/kernel.asm	/^pageinfo *$/;"	l
panic	inc/assert.h	27;"	d
panicstr	kern/debug.c	/^static const char *panicstr;$/;"	v	file:
panicstr	obj/kern/kernel.asm	/^		panicstr = fmt;$/;"	d
pass	misc/grade-functions.sh	/^pass () {$/;"	f
passfailmsg	misc/grade-functions.sh	/^passfailmsg () {$/;"	f
pause	inc/x86.h	/^pause(void)$/;"	f
pd_base	inc/mmu.h	/^	uint32_t gcc_packed	pd_base;	\/\/ Base - NOT 4-byte aligned!$/;"	m	struct:pseudodesc
pd_lim	inc/mmu.h	/^	uint16_t		pd_lim;		\/\/ Limit$/;"	m	struct:pseudodesc
pid_t	inc/types.h	/^typedef int			pid_t;		\/\/ process IDs$/;"	t
pos	obj/kern/kernel.asm	/^	pos = inb(addr_6845 + 1) << 8;$/;"	d
pp0	obj/kern/kernel.asm	/^	pp0 = mem_alloc(); assert(pp0 != 0);$/;"	d
pp0	obj/kern/kernel.asm	/^	pp0 = pp1 = pp2 = 0;$/;"	d
pp1	obj/kern/kernel.asm	/^	pp1 = mem_alloc(); assert(pp1 != 0);$/;"	d
pp2	obj/kern/kernel.asm	/^	pp2 = mem_alloc(); assert(pp2 != 0);$/;"	d
prec	lib/printfmt.c	/^	int prec;		\/\/ numeric precision or string length, -1=none$/;"	m	struct:printstate	file:
printbuf	lib/cprintf.c	/^struct printbuf {$/;"	s	file:
printstate	lib/printfmt.c	/^typedef struct printstate {$/;"	s	file:
printstate	lib/printfmt.c	/^} printstate;$/;"	t	typeref:struct:printstate	file:
proghdr	inc/elf.h	/^typedef struct proghdr {$/;"	s
proghdr	inc/elf.h	/^} proghdr;$/;"	t	typeref:struct:proghdr
protcseg	boot/boot.S	/^protcseg:$/;"	l
protcseg	obj/boot/bootblock.asm	/^protcseg:$/;"	l
pseudodesc	inc/mmu.h	/^struct pseudodesc {$/;"	s
pseudodesc	inc/mmu.h	/^typedef struct pseudodesc pseudodesc;$/;"	t	typeref:struct:pseudodesc
ptrdiff_t	inc/types.h	/^typedef int			ptrdiff_t;	\/\/ difference between pointers$/;"	t
pushregs	inc/trap.h	/^typedef struct pushregs {$/;"	s
pushregs	inc/trap.h	/^} pushregs;$/;"	t	typeref:struct:pushregs
putch	lib/cprintf.c	/^putch(int ch, struct printbuf *b)$/;"	f	file:
putch	lib/printfmt.c	/^	void (*putch)(int ch, void *putdat);	\/\/ character output function$/;"	m	struct:printstate	file:
putdat	lib/printfmt.c	/^	void *putdat;		\/\/ data for above function$/;"	m	struct:printstate	file:
putfinf	lib/printfmt.c	/^putfinf(printstate *st, const char *str)$/;"	f	file:
putflexp	lib/printfmt.c	/^putflexp(printstate *st, double num, int l10, int fmtch)$/;"	f	file:
putflgen	lib/printfmt.c	/^putflgen(printstate *st, double num, int l10, int fmtch)$/;"	f	file:
putfloat	lib/printfmt.c	/^putfloat(printstate *st, double num, int l10, int fmtch)$/;"	f	file:
putint	lib/printfmt.c	/^putint(printstate *st, uintmax_t num, int base)$/;"	f	file:
putpad	lib/printfmt.c	/^putpad(printstate *st)$/;"	f	file:
putstr	lib/printfmt.c	/^putstr(printstate *st, const char *str, int maxlen)$/;"	f	file:
rcr0	inc/x86.h	/^rcr0(void)$/;"	f
rcr2	inc/x86.h	/^rcr2(void)$/;"	f
rcr3	inc/x86.h	/^rcr3(void)$/;"	f
rcr4	inc/x86.h	/^rcr4(void)$/;"	f
rdtsc	inc/x86.h	/^rdtsc(void)$/;"	f
read_cs	inc/x86.h	/^read_cs(void)$/;"	f
read_ebp	inc/x86.h	/^read_ebp(void)$/;"	f
read_eflags	inc/x86.h	/^read_eflags(void)$/;"	f
read_esp	inc/x86.h	/^read_esp(void)$/;"	f
readdeps	misc/mergedep.pl	/^sub readdeps {$/;"	s
readsect	boot/main.c	/^readsect(void *dst, uint32_t offset)$/;"	f
readseg	boot/main.c	/^readseg(uint32_t va, uint32_t count, uint32_t offset)$/;"	f
recover	kern/cpu.h	/^	gcc_noreturn void (*recover)(trapframe *tf, void *recoverdata);$/;"	m	struct:cpu
recoverdata	kern/cpu.h	/^	void		*recoverdata;$/;"	m	struct:cpu
refcount	kern/mem.h	/^	int32_t	refcount;		\/\/ Reference count on allocated pages$/;"	m	struct:pageinfo
regs	inc/trap.h	/^	pushregs regs;$/;"	m	struct:trapframe
reip	kern/trap.h	/^	void *reip;		\/\/ In: EIP at which to resume trapping code$/;"	m	struct:trap_check_args
reserved1	inc/trap.h	/^	uint16_t	reserved1;$/;"	m	struct:fxsave
reserved2	inc/trap.h	/^	uint16_t	reserved2;$/;"	m	struct:fxsave
reserved3	inc/trap.h	/^	uint8_t		reserved3[11][16];	\/\/ byte 288: reserved area$/;"	m	struct:fxsave
reswitch	obj/kern/kernel.asm	/^	reswitch:$/;"	l
ret	obj/kern/kernel.asm	/^	ret = dst;$/;"	d
rpos	kern/cons.c	/^	uint32_t rpos;$/;"	m	struct:__anon1	file:
run	misc/grade-functions.sh	/^run () {$/;"	f
s	obj/kern/kernel.asm	/^				s = "(null)";$/;"	d
s	obj/kern/kernel.asm	/^	s = src;$/;"	d
sd_avl	inc/mmu.h	/^	unsigned sd_avl : 1;        \/\/ Unused (available for software use)$/;"	m	struct:segdesc
sd_base_15_0	inc/mmu.h	/^	unsigned sd_base_15_0 : 16; \/\/ Low bits of segment base address$/;"	m	struct:segdesc
sd_base_23_16	inc/mmu.h	/^	unsigned sd_base_23_16 : 8; \/\/ Middle bits of segment base address$/;"	m	struct:segdesc
sd_base_31_24	inc/mmu.h	/^	unsigned sd_base_31_24 : 8; \/\/ High bits of segment base address$/;"	m	struct:segdesc
sd_db	inc/mmu.h	/^	unsigned sd_db : 1;         \/\/ 0 = 16-bit segment, 1 = 32-bit segment$/;"	m	struct:segdesc
sd_dpl	inc/mmu.h	/^	unsigned sd_dpl : 2;        \/\/ Descriptor Privilege Level$/;"	m	struct:segdesc
sd_g	inc/mmu.h	/^	unsigned sd_g : 1;          \/\/ Granularity: limit scaled by 4K when set$/;"	m	struct:segdesc
sd_lim_15_0	inc/mmu.h	/^	unsigned sd_lim_15_0 : 16;  \/\/ Low bits of segment limit$/;"	m	struct:segdesc
sd_lim_19_16	inc/mmu.h	/^	unsigned sd_lim_19_16 : 4;  \/\/ High bits of segment limit$/;"	m	struct:segdesc
sd_p	inc/mmu.h	/^	unsigned sd_p : 1;          \/\/ Present$/;"	m	struct:segdesc
sd_rsv1	inc/mmu.h	/^	unsigned sd_rsv1 : 1;       \/\/ Reserved$/;"	m	struct:segdesc
sd_s	inc/mmu.h	/^	unsigned sd_s : 1;          \/\/ 0 = system, 1 = application$/;"	m	struct:segdesc
sd_type	inc/mmu.h	/^	unsigned sd_type : 4;       \/\/ Segment type (see STS_ constants)$/;"	m	struct:segdesc
sechdr	inc/elf.h	/^typedef struct sechdr {$/;"	s
sechdr	inc/elf.h	/^} sechdr;$/;"	t	typeref:struct:sechdr
segdesc	inc/mmu.h	/^typedef struct segdesc {$/;"	s
segdesc	inc/mmu.h	/^} segdesc;$/;"	t	typeref:struct:segdesc
serial_exists	dev/serial.c	/^bool serial_exists;$/;"	v
serial_exists	obj/kern/kernel.asm	/^	serial_exists = (inb(COM1+COM_LSR) != 0xFF);$/;"	d
serial_init	dev/serial.c	/^serial_init(void)$/;"	f
serial_intr	dev/serial.c	/^serial_intr(void)$/;"	f
serial_proc_data	dev/serial.c	/^serial_proc_data(void)$/;"	f	file:
serial_putc	dev/serial.c	/^serial_putc(int c)$/;"	f
sh_addr	inc/elf.h	/^	uint32_t sh_addr;$/;"	m	struct:sechdr
sh_addralign	inc/elf.h	/^	uint32_t sh_addralign;$/;"	m	struct:sechdr
sh_entsize	inc/elf.h	/^	uint32_t sh_entsize;$/;"	m	struct:sechdr
sh_flags	inc/elf.h	/^	uint32_t sh_flags;$/;"	m	struct:sechdr
sh_info	inc/elf.h	/^	uint32_t sh_info;$/;"	m	struct:sechdr
sh_link	inc/elf.h	/^	uint32_t sh_link;$/;"	m	struct:sechdr
sh_name	inc/elf.h	/^	uint32_t sh_name;$/;"	m	struct:sechdr
sh_offset	inc/elf.h	/^	uint32_t sh_offset;$/;"	m	struct:sechdr
sh_size	inc/elf.h	/^	uint32_t sh_size;$/;"	m	struct:sechdr
sh_type	inc/elf.h	/^	uint32_t sh_type;$/;"	m	struct:sechdr
shiftcode	dev/kbd.c	/^static uint8_t shiftcode[256] = $/;"	v	file:
shiftmap	dev/kbd.c	/^static uint8_t shiftmap[256] = $/;"	v	file:
signc	lib/printfmt.c	/^	int signc;		\/\/ sign character: '+', '-', ' ', or -1=none$/;"	m	struct:printstate	file:
size_t	inc/types.h	/^typedef unsigned		size_t;$/;"	t
size_t	obj/kern/kernel.asm	/^size_t$/;"	l
spin	boot/boot.S	/^spin:$/;"	l
spin	kern/entry.S	/^spin:	jmp	spin$/;"	l
spin	obj/boot/bootblock.asm	/^spin:$/;"	l
spin	obj/kern/kernel.asm	/^spin:	jmp	spin$/;"	l
ss	inc/trap.h	/^	uint16_t ss;		uint16_t padding_ss;$/;"	m	struct:trapframe
ssize_t	inc/types.h	/^typedef int			ssize_t;$/;"	t
st_mm	inc/trap.h	/^	uint8_t		st_mm[8][16];		\/\/ byte 32: x87\/MMX registers$/;"	m	struct:fxsave
start	boot/boot.S	/^start:$/;"	l
start	kern/entry.S	/^start: _start:$/;"	l
start	obj/boot/bootblock.asm	/^start:$/;"	l
start	obj/kern/kernel.asm	/^start: _start:$/;"	l
static	obj/boot/bootblock.asm	/^static gcc_inline uint8_t$/;"	l
static	obj/boot/bootblock.asm	/^static gcc_inline void$/;"	l
static	obj/kern/kernel.asm	/^static char *$/;"	l
static	obj/kern/kernel.asm	/^static gcc_inline uint16_t$/;"	l
static	obj/kern/kernel.asm	/^static gcc_inline uint32_t$/;"	l
static	obj/kern/kernel.asm	/^static gcc_inline uint8_t$/;"	l
static	obj/kern/kernel.asm	/^static gcc_inline void$/;"	l
static	obj/kern/kernel.asm	/^static inline cpu *$/;"	l
static	obj/kern/kernel.asm	/^static inline int$/;"	l
static	obj/kern/kernel.asm	/^static int$/;"	l
static	obj/kern/kernel.asm	/^static intmax_t$/;"	l
static	obj/kern/kernel.asm	/^static uint16_t crt_pos;$/;"	l
static	obj/kern/kernel.asm	/^static uintmax_t$/;"	l
static	obj/kern/kernel.asm	/^static void gcc_noinline f1(int r, uint32_t *e) { r & 1 ? f2(r,e) : f2(r,e); }$/;"	l
static	obj/kern/kernel.asm	/^static void gcc_noinline f2(int r, uint32_t *e) { r & 2 ? f3(r,e) : f3(r,e); }$/;"	l
static	obj/kern/kernel.asm	/^static void gcc_noinline f3(int r, uint32_t *e) { debug_trace(read_ebp(), e); }$/;"	l
static	obj/kern/kernel.asm	/^static void gcc_noreturn$/;"	l
static	obj/kern/kernel.asm	/^static void$/;"	l
static_assert	inc/assert.h	38;"	d
sti	inc/x86.h	/^sti(void)$/;"	f
strchr	lib/string.c	/^strchr(const char *s, char c)$/;"	f
strcmp	lib/string.c	/^strcmp(const char *p, const char *q)$/;"	f
strcpy	lib/string.c	/^strcpy(char *dst, const char *src)$/;"	f
strlcpy	lib/string.c	/^strlcpy(char *dst, const char *src, size_t size)$/;"	f
strlen	lib/string.c	/^strlen(const char *s)$/;"	f
strncmp	lib/string.c	/^strncmp(const char *p, const char *q, size_t n)$/;"	f
strncpy	lib/string.c	/^strncpy(char *dst, const char *src, size_t size)$/;"	f
taskstate	inc/mmu.h	/^typedef struct taskstate {$/;"	s
taskstate	inc/mmu.h	/^} taskstate;$/;"	t	typeref:struct:taskstate
tlbflush	inc/x86.h	/^tlbflush(void)$/;"	f
togglecode	dev/kbd.c	/^static uint8_t togglecode[256] = $/;"	v	file:
trap	kern/trap.c	/^trap(trapframe *tf)$/;"	f
trap_check	kern/trap.c	/^trap_check(void **argsp)$/;"	f
trap_check_args	kern/trap.h	/^typedef struct trap_check_args {$/;"	s
trap_check_args	kern/trap.h	/^} trap_check_args;$/;"	t	typeref:struct:trap_check_args
trap_check_kernel	kern/trap.c	/^trap_check_kernel(void)$/;"	f
trap_check_recover	kern/trap.c	/^trap_check_recover(trapframe *tf, void *recoverdata)$/;"	f	file:
trap_check_user	kern/trap.c	/^trap_check_user(void)$/;"	f
trap_init	kern/trap.c	/^trap_init(void)$/;"	f
trap_init_idt	kern/trap.c	/^trap_init_idt(void)$/;"	f	file:
trap_name	kern/trap.c	/^const char *trap_name(int trapno)$/;"	f
trap_print	kern/trap.c	/^trap_print(trapframe *tf)$/;"	f
trap_print_regs	kern/trap.c	/^trap_print_regs(pushregs *regs)$/;"	f
trap_return	kern/trapasm.S	/^trap_return:$/;"	l
trap_return	obj/kern/kernel.asm	/^trap_return:$/;"	l
trapframe	inc/trap.h	/^typedef struct trapframe {$/;"	s
trapframe	inc/trap.h	/^} trapframe;$/;"	t	typeref:struct:trapframe
trapframe_ksize	inc/trap.h	114;"	d
trapframe_usize	inc/trap.h	113;"	d
trapno	inc/trap.h	/^	uint32_t trapno;$/;"	m	struct:trapframe
trapno	kern/trap.h	/^	int trapno;		\/\/ Out: trap number from trapframe$/;"	m	struct:trap_check_args
true	inc/types.h	27;"	d
ts_cr3	inc/mmu.h	/^	uintptr_t ts_cr3;	\/\/ Page directory base$/;"	m	struct:taskstate
ts_cs	inc/mmu.h	/^	uint16_t ts_cs;$/;"	m	struct:taskstate
ts_ds	inc/mmu.h	/^	uint16_t ts_ds;$/;"	m	struct:taskstate
ts_eax	inc/mmu.h	/^	uint32_t ts_eax;	\/\/ More saved state (registers)$/;"	m	struct:taskstate
ts_ebp	inc/mmu.h	/^	uintptr_t ts_ebp;$/;"	m	struct:taskstate
ts_ebx	inc/mmu.h	/^	uint32_t ts_ebx;$/;"	m	struct:taskstate
ts_ecx	inc/mmu.h	/^	uint32_t ts_ecx;$/;"	m	struct:taskstate
ts_edi	inc/mmu.h	/^	uint32_t ts_edi;$/;"	m	struct:taskstate
ts_edx	inc/mmu.h	/^	uint32_t ts_edx;$/;"	m	struct:taskstate
ts_eflags	inc/mmu.h	/^	uint32_t ts_eflags;$/;"	m	struct:taskstate
ts_eip	inc/mmu.h	/^	uintptr_t ts_eip;	\/\/ Saved state from last task switch$/;"	m	struct:taskstate
ts_es	inc/mmu.h	/^	uint16_t ts_es;		\/\/ Even more saved state (segment selectors)$/;"	m	struct:taskstate
ts_esi	inc/mmu.h	/^	uint32_t ts_esi;$/;"	m	struct:taskstate
ts_esp	inc/mmu.h	/^	uintptr_t ts_esp;$/;"	m	struct:taskstate
ts_esp0	inc/mmu.h	/^	uintptr_t ts_esp0;	\/\/ Stack pointers and segment selectors$/;"	m	struct:taskstate
ts_esp1	inc/mmu.h	/^	uintptr_t ts_esp1;$/;"	m	struct:taskstate
ts_esp2	inc/mmu.h	/^	uintptr_t ts_esp2;$/;"	m	struct:taskstate
ts_fs	inc/mmu.h	/^	uint16_t ts_fs;$/;"	m	struct:taskstate
ts_gs	inc/mmu.h	/^	uint16_t ts_gs;$/;"	m	struct:taskstate
ts_iomb	inc/mmu.h	/^	uint16_t ts_iomb;	\/\/ I\/O map base address$/;"	m	struct:taskstate
ts_ldt	inc/mmu.h	/^	uint16_t ts_ldt;$/;"	m	struct:taskstate
ts_link	inc/mmu.h	/^	uint32_t ts_link;	\/\/ Old ts selector$/;"	m	struct:taskstate
ts_padding1	inc/mmu.h	/^	uint16_t ts_padding1;$/;"	m	struct:taskstate
ts_padding10	inc/mmu.h	/^	uint16_t ts_padding10;$/;"	m	struct:taskstate
ts_padding2	inc/mmu.h	/^	uint16_t ts_padding2;$/;"	m	struct:taskstate
ts_padding3	inc/mmu.h	/^	uint16_t ts_padding3;$/;"	m	struct:taskstate
ts_padding4	inc/mmu.h	/^	uint16_t ts_padding4;$/;"	m	struct:taskstate
ts_padding5	inc/mmu.h	/^	uint16_t ts_padding5;$/;"	m	struct:taskstate
ts_padding6	inc/mmu.h	/^	uint16_t ts_padding6;$/;"	m	struct:taskstate
ts_padding7	inc/mmu.h	/^	uint16_t ts_padding7;$/;"	m	struct:taskstate
ts_padding8	inc/mmu.h	/^	uint16_t ts_padding8;$/;"	m	struct:taskstate
ts_padding9	inc/mmu.h	/^	uint16_t ts_padding9;$/;"	m	struct:taskstate
ts_ss	inc/mmu.h	/^	uint16_t ts_ss;$/;"	m	struct:taskstate
ts_ss0	inc/mmu.h	/^	uint16_t ts_ss0;	\/\/   after an increase in privilege level$/;"	m	struct:taskstate
ts_ss1	inc/mmu.h	/^	uint16_t ts_ss1;$/;"	m	struct:taskstate
ts_ss2	inc/mmu.h	/^	uint16_t ts_ss2;$/;"	m	struct:taskstate
ts_t	inc/mmu.h	/^	uint16_t ts_t;		\/\/ Trap on task switch$/;"	m	struct:taskstate
tss	kern/cpu.h	/^	taskstate	tss;$/;"	m	struct:cpu
uint16_t	inc/types.h	/^typedef unsigned short		uint16_t;$/;"	t
uint32_t	inc/types.h	/^typedef unsigned int		uint32_t;$/;"	t
uint64_t	inc/types.h	/^typedef unsigned long long	uint64_t;$/;"	t
uint8_t	inc/types.h	/^typedef unsigned char		uint8_t;$/;"	t
uintmax_t	inc/types.h	/^typedef unsigned long long	uintmax_t;$/;"	t
uintptr_t	inc/types.h	/^typedef unsigned		uintptr_t;	\/\/ pointer-size unsigned integer$/;"	t
unsigned	obj/kern/kernel.asm	/^unsigned$/;"	l
user	kern/init.c	/^user()$/;"	f
va_arg	inc/stdarg.h	21;"	d
va_end	inc/stdarg.h	24;"	d
va_list	inc/stdarg.h	/^typedef char *va_list;$/;"	t
va_start	inc/stdarg.h	18;"	d
val	obj/kern/kernel.asm	/^				val = -val;$/;"	d
vcprintf	lib/cprintf.c	/^vcprintf(const char *fmt, va_list ap)$/;"	f
video_init	dev/video.c	/^video_init(void)$/;"	f
video_putc	dev/video.c	/^video_putc(int c)$/;"	f
void	obj/boot/bootblock.asm	/^void$/;"	l
void	obj/kern/kernel.asm	/^void *$/;"	l
void	obj/kern/kernel.asm	/^void after_bound();$/;"	l
void	obj/kern/kernel.asm	/^void after_breakpoint();$/;"	l
void	obj/kern/kernel.asm	/^void after_div0();$/;"	l
void	obj/kern/kernel.asm	/^void after_gpfault();$/;"	l
void	obj/kern/kernel.asm	/^void after_illegal();$/;"	l
void	obj/kern/kernel.asm	/^void after_overflow();$/;"	l
void	obj/kern/kernel.asm	/^void after_priv();$/;"	l
void	obj/kern/kernel.asm	/^void cpu_init()$/;"	l
void	obj/kern/kernel.asm	/^void gcc_noinline$/;"	l
void	obj/kern/kernel.asm	/^void gcc_noreturn$/;"	l
void	obj/kern/kernel.asm	/^void mem_check(void);$/;"	l
void	obj/kern/kernel.asm	/^void$/;"	l
vprintfmt	lib/printfmt.c	/^vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)$/;"	f
waitdisk	boot/main.c	/^waitdisk(void)$/;"	f
warn	inc/assert.h	26;"	d
was	obj/kern/kernel.asm	/^	was = *cp;$/;"	d
width	lib/printfmt.c	/^	int width;		\/\/ field width, -1=none$/;"	m	struct:printstate	file:
wpos	kern/cons.c	/^	uint32_t wpos;$/;"	m	struct:__anon1	file:
write_eflags	inc/x86.h	/^write_eflags(uint32_t eflags)$/;"	f
xadd	inc/x86.h	/^xadd(volatile uint32_t *addr, int32_t incr)$/;"	f
xchg	inc/x86.h	/^xchg(volatile uint32_t *addr, uint32_t newval)$/;"	f
xmm	inc/trap.h	/^	uint8_t		xmm[8][16];		\/\/ byte 160: XMM registers$/;"	m	struct:fxsave
